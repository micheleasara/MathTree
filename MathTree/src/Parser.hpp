#ifndef MATHTREE_PARSER
#define MATHTREE_PARSER

#include <memory>
#include <optional>
#include "Expression.hpp"
#include "InfixParselets.hpp"
#include "Lexer.hpp"
#include <limits>
#include "PrefixParselets.hpp"
#include "Token.hpp"
#include <unordered_map>

namespace MathTree {

/// The abstract interface of a concrete Pratt parser implementation.
class AbstractPrattParser {
public:
  /// Returns the tree of expressions generated by parsing a stream of tokens.
  virtual std::unique_ptr<Expression> parse() = 0;
  /**
   * Returns the tree of expressions generated by parsing a stream of tokens.
   * The parsing stops once a token with a priority lower or equal to the one
   * given is found.
   **/
  virtual std::unique_ptr<Expression> parse(int priority) = 0;
  /// Returns the current token and removes it from the internal cache.
  virtual Token consumeCurrentToken() = 0;
  
  AbstractPrattParser& operator=(AbstractPrattParser const&) = delete;
  AbstractPrattParser& operator=(AbstractPrattParser&&) = delete;
  virtual ~AbstractPrattParser() = default;
};

/// A Pratt parser implementation.
class PrattParser: public AbstractPrattParser {
public:
  /// Represents the minimum priority that a token can have when being parsed.
  static auto constexpr minAllowedPriority = std::numeric_limits<int>::min();
  /// Constructs a Pratt parser with the given lexer as its source of tokens.
  PrattParser(std::unique_ptr<Lexer> lexer);

  //! @copydoc AbstractPrattParser::parse()
  std::unique_ptr<Expression> parse() override;
  //! @copydoc AbstractPrattParser::parse(int)
  std::unique_ptr<Expression> parse(int priority) override;
  /**
   * Returns the expression tree produced by parsing the input string
   * with the priority provided.
   * Effectively sets the internal lexer to tokenise the given input string.
   **/
  std::unique_ptr<Expression> parse(std::string input,
                                    int priority = minAllowedPriority);
  /// Uniquely associates a token type to a prefix parselet.
  void setPrefixParselet(TokenType token, std::unique_ptr<PrefixParselet> parselet);
  /// Uniquely associates a token type to an infix parselet.
  void setInfixParselet(TokenType token, std::unique_ptr<InfixParselet> parselet);
  //! @copydoc AbstractPrattParser::consumeCurrentToken()
  Token consumeCurrentToken() override;
  
private:
  class ReferenceCountingResetter;

  void reset();
  int infixPriorityFor(Token const& token);
  Token const& currentToken();

  std::optional<Token> m_currentToken;
  std::unordered_map<TokenType, std::unique_ptr<PrefixParselet>> m_prefixParselets;
  std::unordered_map<TokenType, std::unique_ptr<InfixParselet>> m_infixParselets;
  std::unique_ptr<Lexer> m_lexer;
  int m_parseCallCount = 0;
};

/// Represents a parser of arithmetic expressions.
class ArithmeticParser {
public:
  /// Represents an error in the way the symbols of the input are arranged.
  enum class SyntaxErrors {
    /// An opening bracket without a corresponding closing bracket.
    UnpairedOpeningBracket,
    /// A closing bracket without a corresponding opening bracket.
    UnpairedClosingBracket,
    /// An operation without the necessary terms.
    IncompleteOperation,
    /// Two or more terms without an operator.
    MissingOperator,
    /// Unknown symbol.
    UnrecognisedSymbol,
    /// Brackets that do not enclose anything between them.
    NothingBetweenBrackets
  };
  /// A list of pairs containing an index and its corresponding syntax error, in this order.
  using IndexErrorPairs = std::vector<std::pair<size_t, SyntaxErrors>>;

  /// A number indicating the order in which operations are solved. Higher is solved earlier.
  enum class OperationPriority {
    Addition = 1,
    Subtraction = 1,
    Sign = 2,
    Multiplication = 2,
    Division = 2,
    Exponentiation = 3,
    SquareRoot = 3,
    Logarithm = 3
  };

  /**
   * Performs a syntactic validation of the given input using the rules of arithmetics.
   * The input is scanned for errors concerning the symbols and their arrangement.
   * Returns a list of indexes and their corresponding error, or an empty list if there are no errors.
   **/
  static IndexErrorPairs validateSyntax(std::string_view input);
  
  /// Creates a parser for arithmetic expressions.
  ArithmeticParser();

  /**
   * Returns a tree of expressions by parsing the given expression.
   * It is recommended to validate the syntax before parsing.
  **/
  std::unique_ptr<Expression> parse(std::string input);

private:
  PrattParser m_parser;
};

}

#endif // MATHTREE_PARSER